export default Module;
declare function Module<T>(target?: T): Promise<T & typeof Module>;
declare module Module {
    function destroy(obj: any): void;
    function _malloc(size: number): number;
    function _free(ptr: number): void;
    function wrapPointer<C extends new (...args: any) => any>(ptr: number, Class: C): InstanceType<C>;
    function getPointer(obj: unknown): number;
    function castObject<C extends new (...args: any) => any>(object: unknown, Class: C): InstanceType<C>;
    function compare(object1: unknown, object2: unknown): boolean;
    const HEAP8: Int8Array;
    const HEAP16: Int16Array;
    const HEAP32: Int32Array;
    const HEAPU8: Uint8Array;
    const HEAPU16: Uint16Array;
    const HEAPU32: Uint32Array;
    const HEAPF32: Float32Array;
    const HEAPF64: Float64Array;
    class TFT_eSPI {
        constructor(w: number, h: number);
        init(): void;
        drawPixel(x: number, y: number, color: number): void;
        drawChar(x: number, y: number, c: number, color: number, bg: number, size: number): void;
        drawLine(xs: number, ys: number, xe: number, ye: number, color: number): void;
        drawFastVLine(x: number, y: number, h: number, color: number): void;
        drawFastHLine(x: number, y: number, w: number, color: number): void;
        fillRect(x: number, y: number, w: number, h: number, color: number): void;
        drawChar(uniCode: number, x: number, y: number, font: number): void;
        drawChar(uniCode: number, x: number, y: number): void;
        height(): number;
        width(): number;
        readPixel(x: number, y: number): number;
        setWindow(xs: number, ys: number, xe: number, ye: number): void;
        pushColor(color: number): void;
        setRotation(r: number): void;
        getRotation(): number;
        setOrigin(x: number, y: number): void;
        getOriginX(): number;
        getOriginY(): number;
        invertDisplay(i: boolean): void;
        setAddrWindow(xs: number, ys: number, w: number, h: number): void;
        setViewport(x: number, y: number, w: number, h: number, vpDatum?: boolean): void;
        checkViewport(x: number, y: number, w: number, h: number): boolean;
        getViewportX(): number;
        getViewportY(): number;
        getViewportWidth(): number;
        getViewportHeight(): number;
        getViewportDatum(): boolean;
        frameViewport(color: number, w: number): void;
        resetViewport(): void;
        pushColor(color: number, len: number): void;
        pushColors(data: ReadonlyArray<number>, len: number, swap?: boolean): void;
        pushBlock(color: number, len: number): void;
        pushPixels(data_in: ReadonlyArray<number>, len: number): void;
        fillScreen(color: number): void;
        drawRect(x: number, y: number, w: number, h: number, color: number): void;
        drawRoundRect(x: number, y: number, w: number, h: number, radius: number, color: number): void;
        fillRoundRect(x: number, y: number, w: number, h: number, radius: number, color: number): void;
        fillRectVGradient(x: number, y: number, w: number, h: number, color1: number, color2: number): void;
        fillRectHGradient(x: number, y: number, w: number, h: number, color1: number, color2: number): void;
        drawCircle(x: number, y: number, r: number, color: number): void;
        drawCircleHelper(x: number, y: number, r: number, cornername: number, color: number): void;
        fillCircle(x: number, y: number, r: number, color: number): void;
        fillCircleHelper(x: number, y: number, r: number, cornername: number, delta: number, color: number): void;
        drawEllipse(x: number, y: number, rx: number, ry: number, color: number): void;
        fillEllipse(x: number, y: number, rx: number, ry: number, color: number): void;
        drawTriangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number): void;
        fillTriangle(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number): void;
        drawSmoothArc(x: number, y: number, r: number, ir: number, startAngle: number, endAngle: number, fg_color: number, bg_color: number, roundEnds?: boolean): void;
        drawArc(x: number, y: number, r: number, ir: number, startAngle: number, endAngle: number, fg_color: number, bg_color: number, smoothArc?: boolean): void;
        drawSmoothCircle(x: number, y: number, r: number, fg_color: number, bg_color: number): void;
        fillSmoothCircle(x: number, y: number, r: number, color: number, bg_color?: number): void;
        drawSmoothRoundRect(x: number, y: number, r: number, ir: number, w: number, h: number, fg_color: number, bg_color?: number, quadrants?: number): void;
        fillSmoothRoundRect(x: number, y: number, w: number, h: number, radius: number, color: number, bg_color?: number): void;
        drawSpot(ax: number, ay: number, r: number, fg_color: number, bg_color?: number): void;
        drawWideLine(ax: number, ay: number, bx: number, by: number, wd: number, fg_color: number, bg_color?: number): void;
        drawWedgeLine(ax: number, ay: number, bx: number, by: number, aw: number, bw: number, fg_color: number, bg_color?: number): void;
        setSwapBytes(swap: boolean): void;
        getSwapBytes(): boolean;
        drawBitmap(x: number, y: number, bitmap: ReadonlyArray<number>, w: number, h: number, fgcolor: number): void;
        drawBitmap(x: number, y: number, bitmap: ReadonlyArray<number>, w: number, h: number, fgcolor: number, bgcolor: number): void;
        setPivot(x: number, y: number): void;
        getPivotX(): number;
        getPivotY(): number;
        pushRect(x: number, y: number, w: number, h: number, data: ReadonlyArray<number>): void;
        pushImage(x: number, y: number, w: number, h: number, data: ReadonlyArray<number>): void;
        pushImage(x: number, y: number, w: number, h: number, data: ReadonlyArray<number>, transparent: number): void;
        pushMaskedImage(x: number, y: number, w: number, h: number, img: ReadonlyArray<number>, mask: ReadonlyArray<number>): void;
        drawNumber(intNumber: number, x: number, y: number, font: number): number;
        drawNumber(intNumber: number, x: number, y: number): number;
        drawFloat(floatNumber: number, decimal: number, x: number, y: number, font: number): number;
        drawFloat(floatNumber: number, decimal: number, x: number, y: number): number;
        drawString(string: string, x: number, y: number, font: number): number;
        drawString(string: string, x: number, y: number): number;
        setCursor(x: number, y: number): void;
        setCursor(x: number, y: number, font: number): void;
        getCursorX(): number;
        getCursorY(): number;
        setTextColor(color: number): void;
        setTextColor(fgcolor: number, bgcolor: number, bgfill?: boolean): void;
        setTextSize(size: number): void;
        setTextWrap(wrapX: boolean, wrapY?: boolean): void;
        setTextDatum(datum: number): void;
        getTextDatum(): number;
        setTextPadding(x_width: number): void;
        getTextPadding(): number;
        setTextFont(font: number): void;
        textWidth(string: string, font: number): number;
        textWidth(string: string): number;
        fontHeight(font: number): number;
        fontHeight(): number;
        color565(red: number, green: number, blue: number): number;
        color8to16(color332: number): number;
        color16to8(color565: number): number;
        color16to24(color565: number): number;
        color24to16(color888: number): number;
        alphaBlend(alpha: number, fgc: number, bgc: number): number;
        alphaBlend(alpha: number, fgc: number, bgc: number, dither: number): number;
        alphaBlend24(alpha: number, fgc: number, bgc: number, dither?: number): number;
        loadFont(array: ReadonlyArray<number>): void;
        unloadFont(): void;
    }
    class TFT_eSprite extends TFT_eSPI {
        constructor(tft: TFT_eSPI);
        createSprite(width: number, height: number, frames?: number): void;
        created(): boolean;
        setColorDepth(b: number): void;
        getColorDepth(): number;
        createPalette(palette: ReadonlyArray<number>, colors?: number): void;
        setPaletteColor(index: number, color: number): void;
        getPaletteColor(index: number): number;
        setBitmapColor(fg: number, bg: number): void;
        fillSprite(color: number): void;
        setScrollRect(x: number, y: number, w: number, h: number, color?: number): void;
        scroll(dx: number, dy?: number): void;
        pushRotated(spr: TFT_eSprite, angle: number, transp?: number): boolean;
        pushSprite(tx: number, ty: number, sx: number, sy: number, sw: number, sh: number): boolean;
        pushToSprite(dspr: TFT_eSprite, x: number, y: number): boolean;
        pushToSprite(dspr: TFT_eSprite, x: number, y: number, transparent: number): boolean;
        printToSprite(string: string): void;
    }
    class DisplayContext {
        constructor(width: number, height: number);
        DrawToScreen(sprite: TFT_eSprite): void;
    }
}
